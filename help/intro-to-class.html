<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Taller de R: Estadística y programación</title>
    <meta charset="utf-8" />
    <meta name="author" content="Eduard Martinez" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/fc.css" rel="stylesheet" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Taller de R: Estadística y programación
## Lectura 8: Crear funciones en R
### Eduard Martinez
### Universidad de los Andes | <a href="https://github.com/taller-R">ECON-1302</a>

---




# Ya vimos

1. Bucles o loops en R - [[Ver repositorio aquí]](https://github.com/taller-R/clase_7)

--

# Hoy veremos 

1. [function()](#intro)

    1.1. Estructura de una funcíón

2. [Controles de flujo](#flow)

    2.1. message, warning y error

3. [Depurar errores (Debugging)](#error)

    3.1. traceback, debug y recover


&lt;!----------------&gt;
&lt;!--- function ---&gt;
&lt;!----------------&gt;
---
class: inverse, center, middle
name: intro
# function()

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#FF007F' size=1px width=796px&gt;&lt;/html&gt;

Una función es la generalización de un código, de tal manera que permita iterar este código sobre un conjunto de objetos homogeneos para obtener un resultado.

---
# Cuerpo de una función

El cuerpo de la función `function` se compone de 3 partes:

* Argumentos o insumos de la función
* Cuerpo de la función
* Producto o salida de la función


```r
nombre_funcion &lt;- function(argumentos){
                  * Que queremos que haga la función
                  * Resultado de la función
}
```

`i` objeto local del loop (asume un valor diferente de `vector` en cada iteración). Cuando termina de ejecutarse la sentencia dentro de `{}`, el loop pasará al siguiente elmento del vector y así hasta que se haya ejecutado la senetencia sobre todos los elementos de `vector`.

`vector` contiene los elementos sobre los que se va a iterar la sentencia del loop. 

`{}` contiene la sentencia o acciones que se ejecutan dentro del loop.

**Nota:** cada acción que se quiera ejecutar en la sentencia se debe escribir en una línea de código diferente (a menos que se use el operador `%&gt;%` o el operador `;`). 

---
# Veamos un ejemplo()

* pasos  de hacer una función debemos:

1. Debemos hacerlo para un caso, antes de generalizar la función.

2. Tener claro el tipo de objeto que espero obtener de la función.

3.Cuando estamos probando una función es importante incorporar dentro del cuerpo de esta alguna función que nos permitan controlar el avance de la función.


```r
### función que limpia los caracteres
f_caracter &lt;- function(x){ 
           x = x %&gt;% toupper(.) %&gt;% trimws(.)
return(x)
}
f_caracter(" Buenos Dias ")
```


&lt;!--------------------------&gt;
&lt;!--- Controles de flujo ---&gt;
&lt;!--------------------------&gt;
---
class: inverse, center, middle
name: flow
# Controles de flujo

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#FF007F' size=1px width=796px&gt;&lt;/html&gt;

Una función es la generalización de un código, de tal manera que permita iterar este código sobre un conjunto de objetos homogeneos para obtener un resultado.

---
# Funciones de control dentro de una función.

Debuguear un código es el proceso de proceso de identificar y corregir errores dentro de él. R tiene varias maneras de indicar cuando algo falla en la ejecución de un fragmento de código, las cuales son importantes conocer para disminuir el tiempo que requiere esta tarea. Cuando ejecutamos cualquier función en R podemos obtener los siguientes resultados:

* `message:` es una notificación que generamos con la función `message()`. Despues de aplicar esta función, la función sigue ejecutándose.

* `warning:` es una notificación que generamos con la función `warning()`, generalmente indica que hay algo que debemos tener en cuenta. Sin embargo, despues de aplicarse la función sigue ejecutándose.

* `error:`  es una notificación de que ocurrió un error importante, se genera con la funcion `stop()`. Después de ejecutarse. la función no sigue ejecutándose.




&lt;!--------------------------&gt;
&lt;!--- Controles de flujo ---&gt;
&lt;!--------------------------&gt;
---
class: inverse, center, middle
name: error
# Depurar errores (Debugging)

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#FF007F' size=1px width=796px&gt;&lt;/html&gt;

Una función es la generalización de un código, de tal manera que permita iterar este código sobre un conjunto de objetos homogeneos para obtener un resultado.

---
# Depurar errores (Debugging)

* `traceback:` esta función imprime sobre la consola la pila de funciones llamadas luego de que un error fatal ocurra.
* `debug:` con esta función se inicia un depurador interactivo (conocido como browser en R) que permite ir paso a paso a través de la ejecución de una función hasta encontrar donde el error ocurre.

* `recover:` con esta función podemos modificar la respuesta de R después de un error. Por ejemplo, con `recover` podemos indicarle a R que detenga la ejecución de la función en el punto exacto donde ocurre el error.

&lt;!---------------------&gt;
&lt;!---    Hoy vimos  ---&gt;
&lt;!---------------------&gt;
---
class: inverse, center, middle

# Hoy vimos...
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#FF007F' size=1px width=796px&gt;&lt;/html&gt;

---
#  Hoy vimos...

- ☑ [Bucles o ciclos](#loops)

- ☑ [Controles de flujo](#flow)

- ☑ [Familia apply](#family)

---
# Vamos a replicar la clase...

&lt;div align="center"&gt;
&lt;img src="pics/run_class.gif" height=550&gt;
&lt;/div&gt;










    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
